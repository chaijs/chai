/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

import {config} from './config.js';
import {AssertionError} from 'assertion-error';
import * as util from './utils/index.js';
import {ChainableBehavior} from './utils/chainableBehavior.js';

export interface AssertionFlags<T> {
  ssfi: Function;
  lockSsfi?: boolean;
  object: T;
  message?: string | null;
  eql: (a: unknown, b: unknown) => boolean;
  deltaBehavior?: string;
  nested?: boolean;
  deep?: boolean;
  [key: PropertyKey]: unknown;
}

type MethodNames<T> = {
  [k in keyof T]: T[k] extends (...args: never) => void ? k : never;
}[keyof T];

const getDefaultValue = <T>(assertion: Assertion<T>): Assertion<T> => {
  var newAssertion = Assertion.create<T>();
  util.transferFlags(assertion, newAssertion);
  return newAssertion;
};

/*!
 * Assertion Constructor
 *
 * Creates object for chaining.
 *
 * `Assertion` objects contain metadata in the form of flags. Three flags can
 * be assigned during instantiation by passing arguments to this constructor:
 *
 * - `object`: This flag contains the target of the assertion. For example, in
 *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
 *   contain `numKittens` so that the `equal` assertion can reference it when
 *   needed.
 *
 * - `message`: This flag contains an optional custom error message to be
 *   prepended to the error message that's generated by the assertion when it
 *   fails.
 *
 * - `ssfi`: This flag stands for "start stack function indicator". It
 *   contains a function reference that serves as the starting point for
 *   removing frames from the stack trace of the error that's created by the
 *   assertion when it fails. The goal is to provide a cleaner stack trace to
 *   end users by removing Chai's internal functions. Note that it only works
 *   in environments that support `Error.captureStackTrace`, and only when
 *   `Chai.config.includeStack` hasn't been set to `false`.
 *
 * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
 *   should retain its current value, even as assertions are chained off of
 *   this object. This is usually set to `true` when creating a new assertion
 *   from within another assertion. It's also temporarily set to `true` before
 *   an overwritten assertion gets called by the overwriting assertion.
 *
 * - `eql`: This flag contains the deepEqual function to be used by the assertion.
 *
 * @param {unknown} obj target of the assertion
 * @param {string} msg (optional) custom error message
 * @param {Function} ssfi (optional) starting point for removing stack frames
 * @param {boolean} lockSsfi (optional) whether or not the ssfi flag is locked
 * @private
 */
export class Assertion<
  T,
  TFlags extends AssertionFlags<T> = AssertionFlags<T>
> {
  declare public __flags: TFlags;
  public __methods: Record<string, ChainableBehavior> = {};

  public constructor(
    obj?: unknown,
    msg?: string | null,
    ssfi?: Function,
    lockSsfi?: boolean
  ) {
    util.flag(this, 'ssfi', ssfi || Assertion);
    util.flag(this, 'lockSsfi', lockSsfi);
    util.flag(this, 'object', obj);
    util.flag(this, 'message', msg);
    util.flag(this, 'eql', config.deepEqual ?? util.eql);
  }

  public static create<TObj>(
    obj?: TObj,
    msg?: string | null,
    ssfi?: Function,
    lockSsfi?: boolean
  ): Assertion<TObj> {
    return util.proxify(new Assertion<TObj>(obj, msg, ssfi, lockSsfi));
  }

  public static get includeStack(): boolean {
    console.warn(
      'Assertion.includeStack is deprecated, use chai.config.includeStack instead.'
    );
    return config.includeStack;
  }

  public static set includeStack(value: boolean) {
    console.warn(
      'Assertion.includeStack is deprecated, use chai.config.includeStack instead.'
    );
    config.includeStack = value;
  }

  public static get showDiff(): boolean {
    console.warn(
      'Assertion.showDiff is deprecated, use chai.config.showDiff instead.'
    );
    return config.showDiff;
  }

  public static set showDiff(value: boolean) {
    console.warn(
      'Assertion.showDiff is deprecated, use chai.config.showDiff instead.'
    );
    config.showDiff = value;
  }

  public static addProperty(
    name: string,
    fn?: (this: Assertion<unknown>) => unknown
  ): void {
    util.addProperty(this.prototype, name, fn, getDefaultValue);
  }

  public static addMethod<TKey extends PropertyKey>(
    name: TKey,
    fn: TKey extends MethodNames<Assertion<unknown>>
      ? (
          this: Assertion<unknown>,
          ...args: Parameters<Assertion<unknown>[TKey]>
        ) => ReturnType<Assertion<unknown>[TKey]> | void
      : (this: Assertion<unknown>, ...args: never) => unknown
  ): void {
    util.addMethod(this.prototype, name, fn, getDefaultValue);
  }

  public static addChainableMethod<T extends unknown[]>(
    name: string,
    fn: (this: Assertion<unknown>, ...args: T) => unknown,
    chainingBehavior?: () => void
  ): void {
    util.addChainableMethod(
      this.prototype,
      name,
      fn,
      chainingBehavior,
      getDefaultValue
    );
  }

  public static overwriteProperty(name: string, fn: Function): void {
    util.overwriteProperty(this.prototype, name, fn, getDefaultValue);
  }

  public static overwriteMethod(name: string, fn: Function): void {
    util.overwriteMethod(this.prototype, name, fn, getDefaultValue);
  }

  public static overwriteChainableMethod(
    name: string,
    fn: Function,
    chainingBehavior: Function
  ): void {
    util.overwriteChainableMethod(
      this.prototype,
      name,
      fn,
      chainingBehavior,
      getDefaultValue
    );
  }

  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {unknown} _expr to be tested
   * @param {string | Function} msg or function that returns message to display if expression fails
   * @param {string | Function} _negateMsg or function that returns negatedMessage to display if negated expression fails
   * @param {unknown} expected value (remember to check for negation)
   * @param {unknown} _actual (optional) will default to `this.obj`
   * @param {boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @private
   */
  public assert(
    _expr: unknown,
    msg?: string | (() => string),
    _negateMsg?: string | (() => string),
    expected?: unknown,
    _actual?: unknown,
    showDiff?: boolean
  ): void {
    var ok = util.test(this, arguments);
    if (false !== showDiff) showDiff = true;
    if (undefined === expected && undefined === _actual) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      msg = util.getMessage(this, arguments);
      var actual = util.getActual(this, arguments);
      var assertionErrorObjectProperties: Record<string, unknown> = {
        actual: actual,
        expected: expected,
        showDiff: showDiff,
        operator: undefined
      };

      var operator = util.getOperator(this, arguments);
      if (operator) {
        assertionErrorObjectProperties.operator = operator;
      }

      throw new AssertionError(
        msg,
        assertionErrorObjectProperties,
        config.includeStack ? this.assert : util.flag(this, 'ssfi')
      );
    }
  }

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @private
   */
  public get _obj(): unknown {
    return util.flag(this, 'object');
  }

  public set _obj(val: unknown) {
    util.flag(this, 'object', val);
  }
}
