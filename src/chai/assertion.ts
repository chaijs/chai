/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

import {config} from './config.js';
import {AssertionError} from 'assertion-error';
import * as util from './utils/index.js';
import {ChainableBehavior} from './utils/chainableBehavior.js';

export interface AssertionFlags {
  ssfi: Function;
  lockSsfi?: boolean;
  object: unknown;
  message?: string | null;
  eql: (a: unknown, b: unknown) => boolean;
  [key: PropertyKey]: unknown;
}

type MethodNames<T> = {
  [k in keyof T]: T[k] extends (...args: never) => void ? k : never;
}[keyof T];

const getDefaultValue = (assertion: Assertion): Assertion => {
    var newAssertion = Assertion.create();
    util.transferFlags(assertion, newAssertion);
    return newAssertion;
};

/*!
 * Assertion Constructor
 *
 * Creates object for chaining.
 *
 * `Assertion` objects contain metadata in the form of flags. Three flags can
 * be assigned during instantiation by passing arguments to this constructor:
 *
 * - `object`: This flag contains the target of the assertion. For example, in
 *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
 *   contain `numKittens` so that the `equal` assertion can reference it when
 *   needed.
 *
 * - `message`: This flag contains an optional custom error message to be
 *   prepended to the error message that's generated by the assertion when it
 *   fails.
 *
 * - `ssfi`: This flag stands for "start stack function indicator". It
 *   contains a function reference that serves as the starting point for
 *   removing frames from the stack trace of the error that's created by the
 *   assertion when it fails. The goal is to provide a cleaner stack trace to
 *   end users by removing Chai's internal functions. Note that it only works
 *   in environments that support `Error.captureStackTrace`, and only when
 *   `Chai.config.includeStack` hasn't been set to `false`.
 *
 * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
 *   should retain its current value, even as assertions are chained off of
 *   this object. This is usually set to `true` when creating a new assertion
 *   from within another assertion. It's also temporarily set to `true` before
 *   an overwritten assertion gets called by the overwriting assertion.
 *
 * - `eql`: This flag contains the deepEqual function to be used by the assertion.
 *
 * @param {Mixed} obj target of the assertion
 * @param {String} msg (optional) custom error message
 * @param {Function} ssfi (optional) starting point for removing stack frames
 * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
 * @api private
 */
export class Assertion {
  declare public __flags: AssertionFlags;
  public __methods: Record<string, ChainableBehavior> = {};

  public constructor(
    obj?: unknown,
    msg?: string | null,
    ssfi?: Function,
    lockSsfi?: boolean
  ) {
    util.flag(this, 'ssfi', ssfi || Assertion);
    util.flag(this, 'lockSsfi', lockSsfi);
    util.flag(this, 'object', obj);
    util.flag(this, 'message', msg);
    util.flag(this, 'eql', config.deepEqual ?? util.eql);
  }

  public static create(
    obj?: unknown,
    msg?: string | null,
    ssfi?: Function,
    lockSsfi?: boolean
  ): Assertion {
    return util.proxify(new Assertion(
      obj,
      msg,
      ssfi,
      lockSsfi
    ));
  }

  public static get includeStack(): boolean {
    console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
    return config.includeStack;
  }

  public static set includeStack(value: boolean) {
    console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
    config.includeStack = value;
  }

  public static get showDiff(): boolean {
    console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
    return config.showDiff;
  }

  public static set showDiff(value: boolean) {
    console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
    config.showDiff = value;
  }

  public static addProperty(name: string, fn?: (this: Assertion) => unknown): void {
    util.addProperty(this.prototype, name, fn, getDefaultValue);
  }

  public static addMethod<
    TKey extends PropertyKey
  >(
    name: TKey,
    fn: TKey extends MethodNames<Assertion> ?
      (this: Assertion, ...args: Parameters<Assertion[TKey]>) => (ReturnType<Assertion[TKey]> extends Assertion ? (Assertion | void) : ReturnType<Assertion[TKey]>) :
      ((this: Assertion, ...args: never) => unknown)
  ): void {
    util.addMethod(this.prototype, name, fn, getDefaultValue);
  }

  public static addChainableMethod<T extends unknown[]>(
    name: string,
    fn: (this: Assertion, ...args: T) => unknown,
    chainingBehavior?: () => void
  ): void {
    util.addChainableMethod(
      this.prototype,
      name,
      fn as (...args: unknown[]) => unknown,
      chainingBehavior,
      getDefaultValue
    );
  }

  public static overwriteProperty(name: string, fn: Function): void {
    util.overwriteProperty(this.prototype, name, fn, getDefaultValue);
  }

  public static overwriteMethod(name: string, fn: Function): void {
    util.overwriteMethod(this.prototype, name, fn, getDefaultValue);
  }

  public static overwriteChainableMethod(name: string, fn: Function, chainingBehavior: Function): void {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior, getDefaultValue);
  }

  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */
  public assert(
    _expr: unknown,
    msg?: string | (() => string),
    _negateMsg?: string | (() => string),
    expected?: unknown,
    _actual?: unknown,
    showDiff?: boolean
  ): void {
    var ok = util.test(this, arguments);
    if (false !== showDiff) showDiff = true;
    if (undefined === expected && undefined === _actual) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      msg = util.getMessage(this, arguments);
      var actual = util.getActual(this, arguments);
      var assertionErrorObjectProperties: Record<string, unknown> = {
          actual: actual
        , expected: expected
        , showDiff: showDiff
        , operator: undefined
      };

      var operator = util.getOperator(this, arguments);
      if (operator) {
        assertionErrorObjectProperties.operator = operator;
      }

      throw new AssertionError(
        msg,
        assertionErrorObjectProperties,
        (config.includeStack) ? this.assert : util.flag(this, 'ssfi'));
    }
  }

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */
  public get _obj(): unknown {
    return util.flag(this, 'object');
  }

  public set _obj(val: unknown) {
    util.flag(this, 'object', val);
  }
}
